// Generated by gencpp from file dfcv_mining_msgs/Radar.msg
// DO NOT EDIT!


#ifndef DFCV_MINING_MSGS_MESSAGE_RADAR_H
#define DFCV_MINING_MSGS_MESSAGE_RADAR_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace dfcv_mining_msgs
{
template <class ContainerAllocator>
struct Radar_
{
  typedef Radar_<ContainerAllocator> Type;

  Radar_()
    : Id1()
    , Id1_Alarm_Level1(0)
    , Id1_State1(0)
    , Id1_Dis1(0.0)
    , Id1_Alarm_Level2(0)
    , Id1_State2(0)
    , Id1_Dis2(0.0)
    , Id1_Alarm_Level3(0)
    , Id1_State3(0)
    , Id1_Dis3(0.0)
    , Id1_Alarm_Level4(0)
    , Id1_State4(0)
    , Id1_Dis4(0.0)
    , Id2()
    , Id2_Alarm_Level1(0)
    , Id2_State1(0)
    , Id2_Dis1(0.0)
    , Id2_Alarm_Level2(0)
    , Id2_State2(0)
    , Id2_Dis2(0.0)
    , Id2_Alarm_Level3(0)
    , Id2_State3(0)
    , Id2_Dis3(0.0)
    , Id2_Alarm_Level4(0)
    , Id2_State4(0)
    , Id2_Dis4(0.0)
    , Id3()
    , Id3_Alarm_Level1(0)
    , Id3_State1(0)
    , Id3_Dis1(0.0)
    , Id3_Alarm_Level2(0)
    , Id3_State2(0)
    , Id3_Dis2(0.0)
    , Id3_Alarm_Level3(0)
    , Id3_State3(0)
    , Id3_Dis3(0.0)
    , Id3_Alarm_Level4(0)
    , Id3_State4(0)
    , Id3_Dis4(0.0)
    , Id4()
    , Id4_Alarm_Level1(0)
    , Id4_State1(0)
    , Id4_Dis1(0.0)
    , Id4_Alarm_Level2(0)
    , Id4_State2(0)
    , Id4_Dis2(0.0)
    , Id4_Alarm_Level3(0)
    , Id4_State3(0)
    , Id4_Dis3(0.0)
    , Id4_Alarm_Level4(0)
    , Id4_State4(0)
    , Id4_Dis4(0.0)  {
    }
  Radar_(const ContainerAllocator& _alloc)
    : Id1(_alloc)
    , Id1_Alarm_Level1(0)
    , Id1_State1(0)
    , Id1_Dis1(0.0)
    , Id1_Alarm_Level2(0)
    , Id1_State2(0)
    , Id1_Dis2(0.0)
    , Id1_Alarm_Level3(0)
    , Id1_State3(0)
    , Id1_Dis3(0.0)
    , Id1_Alarm_Level4(0)
    , Id1_State4(0)
    , Id1_Dis4(0.0)
    , Id2(_alloc)
    , Id2_Alarm_Level1(0)
    , Id2_State1(0)
    , Id2_Dis1(0.0)
    , Id2_Alarm_Level2(0)
    , Id2_State2(0)
    , Id2_Dis2(0.0)
    , Id2_Alarm_Level3(0)
    , Id2_State3(0)
    , Id2_Dis3(0.0)
    , Id2_Alarm_Level4(0)
    , Id2_State4(0)
    , Id2_Dis4(0.0)
    , Id3(_alloc)
    , Id3_Alarm_Level1(0)
    , Id3_State1(0)
    , Id3_Dis1(0.0)
    , Id3_Alarm_Level2(0)
    , Id3_State2(0)
    , Id3_Dis2(0.0)
    , Id3_Alarm_Level3(0)
    , Id3_State3(0)
    , Id3_Dis3(0.0)
    , Id3_Alarm_Level4(0)
    , Id3_State4(0)
    , Id3_Dis4(0.0)
    , Id4(_alloc)
    , Id4_Alarm_Level1(0)
    , Id4_State1(0)
    , Id4_Dis1(0.0)
    , Id4_Alarm_Level2(0)
    , Id4_State2(0)
    , Id4_Dis2(0.0)
    , Id4_Alarm_Level3(0)
    , Id4_State3(0)
    , Id4_Dis3(0.0)
    , Id4_Alarm_Level4(0)
    , Id4_State4(0)
    , Id4_Dis4(0.0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _Id1_type;
  _Id1_type Id1;

   typedef uint8_t _Id1_Alarm_Level1_type;
  _Id1_Alarm_Level1_type Id1_Alarm_Level1;

   typedef uint8_t _Id1_State1_type;
  _Id1_State1_type Id1_State1;

   typedef double _Id1_Dis1_type;
  _Id1_Dis1_type Id1_Dis1;

   typedef uint8_t _Id1_Alarm_Level2_type;
  _Id1_Alarm_Level2_type Id1_Alarm_Level2;

   typedef uint8_t _Id1_State2_type;
  _Id1_State2_type Id1_State2;

   typedef double _Id1_Dis2_type;
  _Id1_Dis2_type Id1_Dis2;

   typedef uint8_t _Id1_Alarm_Level3_type;
  _Id1_Alarm_Level3_type Id1_Alarm_Level3;

   typedef uint8_t _Id1_State3_type;
  _Id1_State3_type Id1_State3;

   typedef double _Id1_Dis3_type;
  _Id1_Dis3_type Id1_Dis3;

   typedef uint8_t _Id1_Alarm_Level4_type;
  _Id1_Alarm_Level4_type Id1_Alarm_Level4;

   typedef uint8_t _Id1_State4_type;
  _Id1_State4_type Id1_State4;

   typedef double _Id1_Dis4_type;
  _Id1_Dis4_type Id1_Dis4;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _Id2_type;
  _Id2_type Id2;

   typedef uint8_t _Id2_Alarm_Level1_type;
  _Id2_Alarm_Level1_type Id2_Alarm_Level1;

   typedef uint8_t _Id2_State1_type;
  _Id2_State1_type Id2_State1;

   typedef double _Id2_Dis1_type;
  _Id2_Dis1_type Id2_Dis1;

   typedef uint8_t _Id2_Alarm_Level2_type;
  _Id2_Alarm_Level2_type Id2_Alarm_Level2;

   typedef uint8_t _Id2_State2_type;
  _Id2_State2_type Id2_State2;

   typedef double _Id2_Dis2_type;
  _Id2_Dis2_type Id2_Dis2;

   typedef uint8_t _Id2_Alarm_Level3_type;
  _Id2_Alarm_Level3_type Id2_Alarm_Level3;

   typedef uint8_t _Id2_State3_type;
  _Id2_State3_type Id2_State3;

   typedef double _Id2_Dis3_type;
  _Id2_Dis3_type Id2_Dis3;

   typedef uint8_t _Id2_Alarm_Level4_type;
  _Id2_Alarm_Level4_type Id2_Alarm_Level4;

   typedef uint8_t _Id2_State4_type;
  _Id2_State4_type Id2_State4;

   typedef double _Id2_Dis4_type;
  _Id2_Dis4_type Id2_Dis4;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _Id3_type;
  _Id3_type Id3;

   typedef uint8_t _Id3_Alarm_Level1_type;
  _Id3_Alarm_Level1_type Id3_Alarm_Level1;

   typedef uint8_t _Id3_State1_type;
  _Id3_State1_type Id3_State1;

   typedef double _Id3_Dis1_type;
  _Id3_Dis1_type Id3_Dis1;

   typedef uint8_t _Id3_Alarm_Level2_type;
  _Id3_Alarm_Level2_type Id3_Alarm_Level2;

   typedef uint8_t _Id3_State2_type;
  _Id3_State2_type Id3_State2;

   typedef double _Id3_Dis2_type;
  _Id3_Dis2_type Id3_Dis2;

   typedef uint8_t _Id3_Alarm_Level3_type;
  _Id3_Alarm_Level3_type Id3_Alarm_Level3;

   typedef uint8_t _Id3_State3_type;
  _Id3_State3_type Id3_State3;

   typedef double _Id3_Dis3_type;
  _Id3_Dis3_type Id3_Dis3;

   typedef uint8_t _Id3_Alarm_Level4_type;
  _Id3_Alarm_Level4_type Id3_Alarm_Level4;

   typedef uint8_t _Id3_State4_type;
  _Id3_State4_type Id3_State4;

   typedef double _Id3_Dis4_type;
  _Id3_Dis4_type Id3_Dis4;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _Id4_type;
  _Id4_type Id4;

   typedef uint8_t _Id4_Alarm_Level1_type;
  _Id4_Alarm_Level1_type Id4_Alarm_Level1;

   typedef uint8_t _Id4_State1_type;
  _Id4_State1_type Id4_State1;

   typedef double _Id4_Dis1_type;
  _Id4_Dis1_type Id4_Dis1;

   typedef uint8_t _Id4_Alarm_Level2_type;
  _Id4_Alarm_Level2_type Id4_Alarm_Level2;

   typedef uint8_t _Id4_State2_type;
  _Id4_State2_type Id4_State2;

   typedef double _Id4_Dis2_type;
  _Id4_Dis2_type Id4_Dis2;

   typedef uint8_t _Id4_Alarm_Level3_type;
  _Id4_Alarm_Level3_type Id4_Alarm_Level3;

   typedef uint8_t _Id4_State3_type;
  _Id4_State3_type Id4_State3;

   typedef double _Id4_Dis3_type;
  _Id4_Dis3_type Id4_Dis3;

   typedef uint8_t _Id4_Alarm_Level4_type;
  _Id4_Alarm_Level4_type Id4_Alarm_Level4;

   typedef uint8_t _Id4_State4_type;
  _Id4_State4_type Id4_State4;

   typedef double _Id4_Dis4_type;
  _Id4_Dis4_type Id4_Dis4;





  typedef boost::shared_ptr< ::dfcv_mining_msgs::Radar_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::dfcv_mining_msgs::Radar_<ContainerAllocator> const> ConstPtr;

}; // struct Radar_

typedef ::dfcv_mining_msgs::Radar_<std::allocator<void> > Radar;

typedef boost::shared_ptr< ::dfcv_mining_msgs::Radar > RadarPtr;
typedef boost::shared_ptr< ::dfcv_mining_msgs::Radar const> RadarConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::dfcv_mining_msgs::Radar_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace dfcv_mining_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'dfcv_mining_msgs': ['/home/yz/catkin_ws/src/dfcv_mining_msgs/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::dfcv_mining_msgs::Radar_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::dfcv_mining_msgs::Radar_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::dfcv_mining_msgs::Radar_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e1d701f079c1187fd70bae216992aafb";
  }

  static const char* value(const ::dfcv_mining_msgs::Radar_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe1d701f079c1187fULL;
  static const uint64_t static_value2 = 0xd70bae216992aafbULL;
};

template<class ContainerAllocator>
struct DataType< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
{
  static const char* value()
  {
    return "dfcv_mining_msgs/Radar";
  }

  static const char* value(const ::dfcv_mining_msgs::Radar_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#超声波雷达:Radar.msg\n\
#第1组\n\
string Id1\n\
uint8 Id1_Alarm_Level1\n\
uint8 Id1_State1\n\
float64 Id1_Dis1\n\
 \n\
uint8 Id1_Alarm_Level2\n\
uint8 Id1_State2\n\
float64 Id1_Dis2\n\
\n\
uint8 Id1_Alarm_Level3\n\
uint8 Id1_State3\n\
float64 Id1_Dis3\n\
\n\
uint8 Id1_Alarm_Level4\n\
uint8 Id1_State4\n\
float64 Id1_Dis4\n\
\n\
#第2组\n\
string Id2\n\
uint8 Id2_Alarm_Level1\n\
uint8 Id2_State1\n\
float64 Id2_Dis1\n\
 \n\
uint8 Id2_Alarm_Level2\n\
uint8 Id2_State2\n\
float64 Id2_Dis2\n\
\n\
uint8 Id2_Alarm_Level3\n\
uint8 Id2_State3\n\
float64 Id2_Dis3\n\
\n\
uint8 Id2_Alarm_Level4\n\
uint8 Id2_State4\n\
float64 Id2_Dis4\n\
\n\
#第3组\n\
string Id3\n\
uint8 Id3_Alarm_Level1\n\
uint8 Id3_State1\n\
float64 Id3_Dis1\n\
 \n\
uint8 Id3_Alarm_Level2\n\
uint8 Id3_State2\n\
float64 Id3_Dis2\n\
\n\
uint8 Id3_Alarm_Level3\n\
uint8 Id3_State3\n\
float64 Id3_Dis3\n\
\n\
uint8 Id3_Alarm_Level4\n\
uint8 Id3_State4\n\
float64 Id3_Dis4\n\
\n\
#第4组\n\
string Id4\n\
uint8 Id4_Alarm_Level1\n\
uint8 Id4_State1\n\
float64 Id4_Dis1\n\
 \n\
uint8 Id4_Alarm_Level2\n\
uint8 Id4_State2\n\
float64 Id4_Dis2\n\
\n\
uint8 Id4_Alarm_Level3\n\
uint8 Id4_State3\n\
float64 Id4_Dis3\n\
\n\
uint8 Id4_Alarm_Level4\n\
uint8 Id4_State4\n\
float64 Id4_Dis4\n\
";
  }

  static const char* value(const ::dfcv_mining_msgs::Radar_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.Id1);
      stream.next(m.Id1_Alarm_Level1);
      stream.next(m.Id1_State1);
      stream.next(m.Id1_Dis1);
      stream.next(m.Id1_Alarm_Level2);
      stream.next(m.Id1_State2);
      stream.next(m.Id1_Dis2);
      stream.next(m.Id1_Alarm_Level3);
      stream.next(m.Id1_State3);
      stream.next(m.Id1_Dis3);
      stream.next(m.Id1_Alarm_Level4);
      stream.next(m.Id1_State4);
      stream.next(m.Id1_Dis4);
      stream.next(m.Id2);
      stream.next(m.Id2_Alarm_Level1);
      stream.next(m.Id2_State1);
      stream.next(m.Id2_Dis1);
      stream.next(m.Id2_Alarm_Level2);
      stream.next(m.Id2_State2);
      stream.next(m.Id2_Dis2);
      stream.next(m.Id2_Alarm_Level3);
      stream.next(m.Id2_State3);
      stream.next(m.Id2_Dis3);
      stream.next(m.Id2_Alarm_Level4);
      stream.next(m.Id2_State4);
      stream.next(m.Id2_Dis4);
      stream.next(m.Id3);
      stream.next(m.Id3_Alarm_Level1);
      stream.next(m.Id3_State1);
      stream.next(m.Id3_Dis1);
      stream.next(m.Id3_Alarm_Level2);
      stream.next(m.Id3_State2);
      stream.next(m.Id3_Dis2);
      stream.next(m.Id3_Alarm_Level3);
      stream.next(m.Id3_State3);
      stream.next(m.Id3_Dis3);
      stream.next(m.Id3_Alarm_Level4);
      stream.next(m.Id3_State4);
      stream.next(m.Id3_Dis4);
      stream.next(m.Id4);
      stream.next(m.Id4_Alarm_Level1);
      stream.next(m.Id4_State1);
      stream.next(m.Id4_Dis1);
      stream.next(m.Id4_Alarm_Level2);
      stream.next(m.Id4_State2);
      stream.next(m.Id4_Dis2);
      stream.next(m.Id4_Alarm_Level3);
      stream.next(m.Id4_State3);
      stream.next(m.Id4_Dis3);
      stream.next(m.Id4_Alarm_Level4);
      stream.next(m.Id4_State4);
      stream.next(m.Id4_Dis4);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Radar_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::dfcv_mining_msgs::Radar_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::dfcv_mining_msgs::Radar_<ContainerAllocator>& v)
  {
    s << indent << "Id1: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.Id1);
    s << indent << "Id1_Alarm_Level1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_Alarm_Level1);
    s << indent << "Id1_State1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_State1);
    s << indent << "Id1_Dis1: ";
    Printer<double>::stream(s, indent + "  ", v.Id1_Dis1);
    s << indent << "Id1_Alarm_Level2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_Alarm_Level2);
    s << indent << "Id1_State2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_State2);
    s << indent << "Id1_Dis2: ";
    Printer<double>::stream(s, indent + "  ", v.Id1_Dis2);
    s << indent << "Id1_Alarm_Level3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_Alarm_Level3);
    s << indent << "Id1_State3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_State3);
    s << indent << "Id1_Dis3: ";
    Printer<double>::stream(s, indent + "  ", v.Id1_Dis3);
    s << indent << "Id1_Alarm_Level4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_Alarm_Level4);
    s << indent << "Id1_State4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id1_State4);
    s << indent << "Id1_Dis4: ";
    Printer<double>::stream(s, indent + "  ", v.Id1_Dis4);
    s << indent << "Id2: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.Id2);
    s << indent << "Id2_Alarm_Level1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_Alarm_Level1);
    s << indent << "Id2_State1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_State1);
    s << indent << "Id2_Dis1: ";
    Printer<double>::stream(s, indent + "  ", v.Id2_Dis1);
    s << indent << "Id2_Alarm_Level2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_Alarm_Level2);
    s << indent << "Id2_State2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_State2);
    s << indent << "Id2_Dis2: ";
    Printer<double>::stream(s, indent + "  ", v.Id2_Dis2);
    s << indent << "Id2_Alarm_Level3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_Alarm_Level3);
    s << indent << "Id2_State3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_State3);
    s << indent << "Id2_Dis3: ";
    Printer<double>::stream(s, indent + "  ", v.Id2_Dis3);
    s << indent << "Id2_Alarm_Level4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_Alarm_Level4);
    s << indent << "Id2_State4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id2_State4);
    s << indent << "Id2_Dis4: ";
    Printer<double>::stream(s, indent + "  ", v.Id2_Dis4);
    s << indent << "Id3: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.Id3);
    s << indent << "Id3_Alarm_Level1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_Alarm_Level1);
    s << indent << "Id3_State1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_State1);
    s << indent << "Id3_Dis1: ";
    Printer<double>::stream(s, indent + "  ", v.Id3_Dis1);
    s << indent << "Id3_Alarm_Level2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_Alarm_Level2);
    s << indent << "Id3_State2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_State2);
    s << indent << "Id3_Dis2: ";
    Printer<double>::stream(s, indent + "  ", v.Id3_Dis2);
    s << indent << "Id3_Alarm_Level3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_Alarm_Level3);
    s << indent << "Id3_State3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_State3);
    s << indent << "Id3_Dis3: ";
    Printer<double>::stream(s, indent + "  ", v.Id3_Dis3);
    s << indent << "Id3_Alarm_Level4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_Alarm_Level4);
    s << indent << "Id3_State4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id3_State4);
    s << indent << "Id3_Dis4: ";
    Printer<double>::stream(s, indent + "  ", v.Id3_Dis4);
    s << indent << "Id4: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.Id4);
    s << indent << "Id4_Alarm_Level1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_Alarm_Level1);
    s << indent << "Id4_State1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_State1);
    s << indent << "Id4_Dis1: ";
    Printer<double>::stream(s, indent + "  ", v.Id4_Dis1);
    s << indent << "Id4_Alarm_Level2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_Alarm_Level2);
    s << indent << "Id4_State2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_State2);
    s << indent << "Id4_Dis2: ";
    Printer<double>::stream(s, indent + "  ", v.Id4_Dis2);
    s << indent << "Id4_Alarm_Level3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_Alarm_Level3);
    s << indent << "Id4_State3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_State3);
    s << indent << "Id4_Dis3: ";
    Printer<double>::stream(s, indent + "  ", v.Id4_Dis3);
    s << indent << "Id4_Alarm_Level4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_Alarm_Level4);
    s << indent << "Id4_State4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Id4_State4);
    s << indent << "Id4_Dis4: ";
    Printer<double>::stream(s, indent + "  ", v.Id4_Dis4);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DFCV_MINING_MSGS_MESSAGE_RADAR_H
