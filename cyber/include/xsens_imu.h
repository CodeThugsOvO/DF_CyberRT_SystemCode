/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Feb 14 15:14:44 2023.
 */

#ifndef XSENS_IMU_H
#define XSENS_IMU_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define XSENS_IMU_STATUS_WORD_FRAME_ID (0x19ff0011u)
#define XSENS_IMU_SAMPLE_TIME_FRAME_ID (0x19ff0005u)
#define XSENS_IMU_GROUP_COUNTER_FRAME_ID (0x19ff0006u)
#define XSENS_IMU_RATE_OF_TURN_FRAME_ID (0x19ff0032u)
#define XSENS_IMU_QUATERNION_FRAME_ID (0x19ff0021u)
#define XSENS_IMU_FREE_ACCELERATION_FRAME_ID (0x19ff0035u)
#define XSENS_IMU_EULER_ANGLES_FRAME_ID (0x19ff0022u)
#define XSENS_IMU_DELTA_V_FRAME_ID (0x19ff0031u)
#define XSENS_IMU_DELTA_Q_FRAME_ID (0x19ff0033u)
#define XSENS_IMU_ACCELERATION_FRAME_ID (0x19ff0034u)
#define XSENS_IMU_ERROR_FRAME_ID (0x19ff0001u)

/* Frame lengths in bytes. */
#define XSENS_IMU_STATUS_WORD_LENGTH (4u)
#define XSENS_IMU_SAMPLE_TIME_LENGTH (4u)
#define XSENS_IMU_GROUP_COUNTER_LENGTH (2u)
#define XSENS_IMU_RATE_OF_TURN_LENGTH (6u)
#define XSENS_IMU_QUATERNION_LENGTH (8u)
#define XSENS_IMU_FREE_ACCELERATION_LENGTH (6u)
#define XSENS_IMU_EULER_ANGLES_LENGTH (6u)
#define XSENS_IMU_DELTA_V_LENGTH (7u)
#define XSENS_IMU_DELTA_Q_LENGTH (8u)
#define XSENS_IMU_ACCELERATION_LENGTH (6u)
#define XSENS_IMU_ERROR_LENGTH (1u)

/* Extended or standard frame types. */
#define XSENS_IMU_STATUS_WORD_IS_EXTENDED (1)
#define XSENS_IMU_SAMPLE_TIME_IS_EXTENDED (1)
#define XSENS_IMU_GROUP_COUNTER_IS_EXTENDED (1)
#define XSENS_IMU_RATE_OF_TURN_IS_EXTENDED (1)
#define XSENS_IMU_QUATERNION_IS_EXTENDED (1)
#define XSENS_IMU_FREE_ACCELERATION_IS_EXTENDED (1)
#define XSENS_IMU_EULER_ANGLES_IS_EXTENDED (1)
#define XSENS_IMU_DELTA_V_IS_EXTENDED (1)
#define XSENS_IMU_DELTA_Q_IS_EXTENDED (1)
#define XSENS_IMU_ACCELERATION_IS_EXTENDED (1)
#define XSENS_IMU_ERROR_IS_EXTENDED (1)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define XSENS_IMU_STATUS_WORD_HAVE_GNSS_TIME_PULSE_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_HAVE_GNSS_TIME_PULSE_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_FILTER_MODE_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_FILTER_MODE_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_MAG_Z_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_MAG_Z_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_RETRANSMITTED_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_RETRANSMITTED_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIPPING_DETECTED_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIPPING_DETECTED_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_INTERPOLATED_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_INTERPOLATED_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_SYNC_IN_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_SYNC_IN_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_SYNC_OUT_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_SYNC_OUT_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_ACC_X_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_ACC_X_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_ACC_Y_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_ACC_Y_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_ACC_Z_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_ACC_Z_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_GYR_X_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_GYR_X_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_GYR_Y_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_GYR_Y_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_GYR_Z_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_GYR_Z_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_MAG_X_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_MAG_X_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_CLIP_MAG_Y_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_CLIP_MAG_Y_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_SELF_TEST_OK_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_SELF_TEST_OK_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_ORIENTATION_VALID_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_ORIENTATION_VALID_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_GPS_VALID_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_GPS_VALID_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_NO_ROTATION_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_NO_ROTATION_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_REPRESENTATIVE_MOTION_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_REPRESENTATIVE_MOTION_TRUE_CHOICE (1u)

#define XSENS_IMU_STATUS_WORD_EXTERNAL_CLOCK_SYNCED_FALSE_CHOICE (0u)
#define XSENS_IMU_STATUS_WORD_EXTERNAL_CLOCK_SYNCED_TRUE_CHOICE (1u)

/**
 * Signals in message StatusWord.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_status_word_t {
    /**
     * Indicates that the 1PPS GNSS time pulse is present
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t have_gnss_time_pulse;

    /**
     * Mask for the 3 bit filter mode field
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t filter_mode;

    /**
     * Indicates if there was clipping on the Z-axis of the magnetometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_mag_z;

    /**
     * When set Indicates the sample was received as a retransmission
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t retransmitted;

    /**
     * When set Indicates clipping has occurred
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clipping_detected;

    /**
     * When set Indicates the sample is an interpolation between other samples
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t interpolated;

    /**
     * When set indicates a sync-in event has been triggered
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sync_in;

    /**
     * When set Indicates a sync-out event has been generated
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sync_out;

    /**
     * Indicates if there was clipping on the X-axis of the accelerometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_acc_x;

    /**
     * Indicates if there was clipping on the Y-axis of the accelerometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_acc_y;

    /**
     * Indicates if there was clipping on the Z-axis of the accelerometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_acc_z;

    /**
     * Indicates if there was clipping on the X-axis of the gyroscope
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_gyr_x;

    /**
     * Indicates if there was clipping on the Y-axis of the gyroscope
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_gyr_y;

    /**
     * Indicates if there was clipping on the Z-axis of the gyroscope
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_gyr_z;

    /**
     * Indicates if there was clipping on the X-axis of the magnetometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_mag_x;

    /**
     * Indicates if there was clipping on the Y-axis of the magnetometer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t clip_mag_y;

    /**
     * Set when the self test result was ok
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t self_test_ok;

    /**
     * Set when the computed orientation is valid. The orientation may be invalid during startup or when the Xsens_Sensor data is clipping during violent (for the device) motion
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t orientation_valid;

    /**
     * Set when the device has a GPS receiver and the receiver says that there is a GPS position fix.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_valid;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_rotation;

    /**
     * Indicates if the In-Run Compass Calibration is doing the representative motion analysis
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t representative_motion;

    /**
     * Indicates whether the internal clock is synced with an external clock (Either GNNS or custom provided clock sync)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t external_clock_synced;
};

/**
 * Signals in message SampleTime.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_sample_time_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;
};

/**
 * Signals in message GroupCounter.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_group_counter_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t counter;
};

/**
 * Signals in message RateOfTurn.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_rate_of_turn_t {
    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t gyr_x;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t gyr_y;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t gyr_z;
};

/**
 * Signals in message Quaternion.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_quaternion_t {
    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q1;

    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q2;

    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q3;

    /**
     * Range: -32768..32768 (-1..1 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q4;
};

/**
 * Signals in message FreeAcceleration.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_free_acceleration_t {
    /**
     * Range: -25600..25600 (-100..100 m/s^2)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t free_acc_x;

    /**
     * Range: -25600..25600 (-100..100 m/s^2)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t free_acc_y;

    /**
     * Range: -25600..25600 (-100..100 m/s^2)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t free_acc_z;
};

/**
 * Signals in message EulerAngles.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_euler_angles_t {
    /**
     * Range: -23040..23040 (-180..180 deg)
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -23040..23040 (-180..180 deg)
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -23040..23040 (-180..180 deg)
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message DeltaV.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_delta_v_t {
    /**
     * Range: -32767.99999978525163520140737..32767.99999978525163520140737 (-0.25..0.25 m/s)
     * Scale: 7.6293945313e-06
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: -32767.99999978525163520140737..32767.99999978525163520140737 (-0.25..0.25 m/s)
     * Scale: 7.6293945313e-06
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: -32767.99999978525163520140737..32767.99999978525163520140737 (-0.25..0.25 m/s)
     * Scale: 7.6293945313e-06
     * Offset: 0
     */
    int16_t z;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t exponent;
};

/**
 * Signals in message DeltaQ.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_delta_q_t {
    /**
     * Range: -32766.99999999698543600000028..32766.99999999698543600000028 (-1..1 m/s^2)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q1;

    /**
     * Range: -32766.99999999698543600000028..32766.99999999698543600000028 (-1..1 m/s^2)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q2;

    /**
     * Range: -32766.99999999698543600000028..32766.99999999698543600000028 (-1..1 m/s^2)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q3;

    /**
     * Range: -32766.99999999698543600000028..32766.99999999698543600000028 (-1..1 m/s^2)
     * Scale: 3.0518509476e-05
     * Offset: 0
     */
    int16_t delta_q4;
};

/**
 * Signals in message Acceleration.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_acceleration_t {
    /**
     * Range: -25600..25600 (-100..100 m/s^2)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t acc_x;

    /**
     * Range: -25600..25600 (-100..100 m/s^2)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t acc_y;

    /**
     * Range: -25600..25600 (-100..100 m/s^2)
     * Scale: 0.00390625
     * Offset: 0
     */
    int16_t acc_z;
};

/**
 * Signals in message Error.
 *
 * All signal values are as on the CAN bus.
 */
struct xsens_imu_error_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Pack message StatusWord.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_status_word_pack(
    uint8_t *dst_p,
    const struct xsens_imu_status_word_t *src_p,
    size_t size);

/**
 * Unpack message StatusWord.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_status_word_unpack(
    struct xsens_imu_status_word_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_have_gnss_time_pulse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_have_gnss_time_pulse_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_have_gnss_time_pulse_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_filter_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_filter_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_filter_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_mag_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_mag_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_mag_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_retransmitted_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_retransmitted_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_retransmitted_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clipping_detected_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clipping_detected_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clipping_detected_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_interpolated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_interpolated_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_interpolated_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_sync_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_sync_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_sync_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_sync_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_sync_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_sync_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_acc_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_acc_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_acc_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_acc_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_acc_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_acc_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_gyr_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_gyr_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_gyr_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_gyr_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_gyr_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_gyr_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_gyr_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_gyr_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_gyr_z_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_mag_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_mag_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_mag_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_clip_mag_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_clip_mag_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_clip_mag_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_self_test_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_self_test_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_self_test_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_orientation_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_orientation_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_orientation_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_gps_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_gps_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_gps_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_no_rotation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_no_rotation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_no_rotation_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_representative_motion_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_representative_motion_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_representative_motion_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_status_word_external_clock_synced_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_status_word_external_clock_synced_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_status_word_external_clock_synced_is_in_range(uint8_t value);

/**
 * Pack message SampleTime.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_sample_time_pack(
    uint8_t *dst_p,
    const struct xsens_imu_sample_time_t *src_p,
    size_t size);

/**
 * Unpack message SampleTime.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_sample_time_unpack(
    struct xsens_imu_sample_time_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t xsens_imu_sample_time_timestamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_sample_time_timestamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_sample_time_timestamp_is_in_range(uint32_t value);

/**
 * Pack message GroupCounter.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_group_counter_pack(
    uint8_t *dst_p,
    const struct xsens_imu_group_counter_t *src_p,
    size_t size);

/**
 * Unpack message GroupCounter.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_group_counter_unpack(
    struct xsens_imu_group_counter_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t xsens_imu_group_counter_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_group_counter_counter_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_group_counter_counter_is_in_range(uint16_t value);

/**
 * Pack message RateOfTurn.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_rate_of_turn_pack(
    uint8_t *dst_p,
    const struct xsens_imu_rate_of_turn_t *src_p,
    size_t size);

/**
 * Unpack message RateOfTurn.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_rate_of_turn_unpack(
    struct xsens_imu_rate_of_turn_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_rate_of_turn_gyr_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_rate_of_turn_gyr_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_rate_of_turn_gyr_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_rate_of_turn_gyr_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_rate_of_turn_gyr_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_rate_of_turn_gyr_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_rate_of_turn_gyr_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_rate_of_turn_gyr_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_rate_of_turn_gyr_z_is_in_range(int16_t value);

/**
 * Pack message Quaternion.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_quaternion_pack(
    uint8_t *dst_p,
    const struct xsens_imu_quaternion_t *src_p,
    size_t size);

/**
 * Unpack message Quaternion.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_quaternion_unpack(
    struct xsens_imu_quaternion_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_quaternion_q1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_quaternion_q1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_quaternion_q1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_quaternion_q2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_quaternion_q2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_quaternion_q2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_quaternion_q3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_quaternion_q3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_quaternion_q3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_quaternion_q4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_quaternion_q4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_quaternion_q4_is_in_range(int16_t value);

/**
 * Pack message FreeAcceleration.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_free_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_imu_free_acceleration_t *src_p,
    size_t size);

/**
 * Unpack message FreeAcceleration.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_free_acceleration_unpack(
    struct xsens_imu_free_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_free_acceleration_free_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_free_acceleration_free_acc_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_free_acceleration_free_acc_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_free_acceleration_free_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_free_acceleration_free_acc_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_free_acceleration_free_acc_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_free_acceleration_free_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_free_acceleration_free_acc_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_free_acceleration_free_acc_z_is_in_range(int16_t value);

/**
 * Pack message EulerAngles.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_euler_angles_pack(
    uint8_t *dst_p,
    const struct xsens_imu_euler_angles_t *src_p,
    size_t size);

/**
 * Unpack message EulerAngles.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_euler_angles_unpack(
    struct xsens_imu_euler_angles_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_euler_angles_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_euler_angles_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_euler_angles_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_euler_angles_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_euler_angles_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_euler_angles_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_euler_angles_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_euler_angles_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_euler_angles_yaw_is_in_range(int16_t value);

/**
 * Pack message DeltaV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_delta_v_pack(
    uint8_t *dst_p,
    const struct xsens_imu_delta_v_t *src_p,
    size_t size);

/**
 * Unpack message DeltaV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_delta_v_unpack(
    struct xsens_imu_delta_v_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_delta_v_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_v_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_v_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_delta_v_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_v_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_v_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_delta_v_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_v_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_v_z_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t xsens_imu_delta_v_exponent_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_v_exponent_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_v_exponent_is_in_range(uint8_t value);

/**
 * Pack message DeltaQ.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_delta_q_pack(
    uint8_t *dst_p,
    const struct xsens_imu_delta_q_t *src_p,
    size_t size);

/**
 * Unpack message DeltaQ.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_delta_q_unpack(
    struct xsens_imu_delta_q_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_delta_q_delta_q1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_q_delta_q1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_q_delta_q1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_delta_q_delta_q2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_q_delta_q2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_q_delta_q2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_delta_q_delta_q3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_q_delta_q3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_q_delta_q3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_delta_q_delta_q4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_delta_q_delta_q4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_delta_q_delta_q4_is_in_range(int16_t value);

/**
 * Pack message Acceleration.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_imu_acceleration_t *src_p,
    size_t size);

/**
 * Unpack message Acceleration.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_acceleration_unpack(
    struct xsens_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_acceleration_acc_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_acceleration_acc_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_acceleration_acc_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_acceleration_acc_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_acceleration_acc_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_acceleration_acc_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t xsens_imu_acceleration_acc_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double xsens_imu_acceleration_acc_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool xsens_imu_acceleration_acc_z_is_in_range(int16_t value);

/**
 * Pack message Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int xsens_imu_error_pack(
    uint8_t *dst_p,
    const struct xsens_imu_error_t *src_p,
    size_t size);

/**
 * Unpack message Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int xsens_imu_error_unpack(
    struct xsens_imu_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);


#ifdef __cplusplus
}
#endif

#endif
