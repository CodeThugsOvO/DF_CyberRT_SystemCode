/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Feb 14 15:14:44 2023.
 */

#include <string.h>

#include "../include/xsens_imu.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t unpack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) << shift);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int xsens_imu_status_word_pack(
    uint8_t *dst_p,
    const struct xsens_imu_status_word_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->have_gnss_time_pulse, 2u, 0x04u);
    dst_p[0] |= pack_right_shift_u8(src_p->filter_mode, 1u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->filter_mode, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->clip_mag_z, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->retransmitted, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->clipping_detected, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->interpolated, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->sync_in, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->sync_out, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_acc_x, 0u, 0x01u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_acc_y, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_acc_z, 2u, 0x04u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_gyr_x, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_gyr_y, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_gyr_z, 5u, 0x20u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_mag_x, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->clip_mag_y, 7u, 0x80u);
    dst_p[3] |= pack_left_shift_u8(src_p->self_test_ok, 0u, 0x01u);
    dst_p[3] |= pack_left_shift_u8(src_p->orientation_valid, 1u, 0x02u);
    dst_p[3] |= pack_left_shift_u8(src_p->gps_valid, 2u, 0x04u);
    dst_p[3] |= pack_left_shift_u8(src_p->no_rotation, 3u, 0x18u);
    dst_p[3] |= pack_left_shift_u8(src_p->representative_motion, 5u, 0x20u);
    dst_p[3] |= pack_left_shift_u8(src_p->external_clock_synced, 6u, 0x40u);

    return (4);
}

int xsens_imu_status_word_unpack(
    struct xsens_imu_status_word_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->have_gnss_time_pulse = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->filter_mode = unpack_left_shift_u8(src_p[0], 1u, 0x03u);
    dst_p->filter_mode |= unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    dst_p->clip_mag_z = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->retransmitted = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->clipping_detected = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->interpolated = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->sync_in = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->sync_out = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->clip_acc_x = unpack_right_shift_u8(src_p[2], 0u, 0x01u);
    dst_p->clip_acc_y = unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->clip_acc_z = unpack_right_shift_u8(src_p[2], 2u, 0x04u);
    dst_p->clip_gyr_x = unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->clip_gyr_y = unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->clip_gyr_z = unpack_right_shift_u8(src_p[2], 5u, 0x20u);
    dst_p->clip_mag_x = unpack_right_shift_u8(src_p[2], 6u, 0x40u);
    dst_p->clip_mag_y = unpack_right_shift_u8(src_p[2], 7u, 0x80u);
    dst_p->self_test_ok = unpack_right_shift_u8(src_p[3], 0u, 0x01u);
    dst_p->orientation_valid = unpack_right_shift_u8(src_p[3], 1u, 0x02u);
    dst_p->gps_valid = unpack_right_shift_u8(src_p[3], 2u, 0x04u);
    dst_p->no_rotation = unpack_right_shift_u8(src_p[3], 3u, 0x18u);
    dst_p->representative_motion = unpack_right_shift_u8(src_p[3], 5u, 0x20u);
    dst_p->external_clock_synced = unpack_right_shift_u8(src_p[3], 6u, 0x40u);

    return (0);
}

uint8_t xsens_imu_status_word_have_gnss_time_pulse_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_have_gnss_time_pulse_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_have_gnss_time_pulse_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_filter_mode_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_filter_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_filter_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_mag_z_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_mag_z_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_mag_z_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_retransmitted_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_retransmitted_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_retransmitted_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clipping_detected_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clipping_detected_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clipping_detected_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_interpolated_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_interpolated_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_interpolated_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_sync_in_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_sync_in_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_sync_in_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_sync_out_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_sync_out_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_sync_out_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_acc_x_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_acc_x_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_acc_x_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_acc_y_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_acc_y_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_acc_y_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_acc_z_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_acc_z_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_acc_z_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_gyr_x_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_gyr_x_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_gyr_x_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_gyr_y_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_gyr_y_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_gyr_y_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_gyr_z_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_gyr_z_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_gyr_z_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_mag_x_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_mag_x_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_mag_x_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_clip_mag_y_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_clip_mag_y_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_clip_mag_y_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_self_test_ok_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_self_test_ok_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_self_test_ok_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_orientation_valid_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_orientation_valid_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_orientation_valid_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_gps_valid_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_gps_valid_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_gps_valid_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_no_rotation_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_no_rotation_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_no_rotation_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t xsens_imu_status_word_representative_motion_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_representative_motion_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_representative_motion_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t xsens_imu_status_word_external_clock_synced_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_status_word_external_clock_synced_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_status_word_external_clock_synced_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int xsens_imu_sample_time_pack(
    uint8_t *dst_p,
    const struct xsens_imu_sample_time_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_right_shift_u32(src_p->timestamp, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->timestamp, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->timestamp, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(src_p->timestamp, 0u, 0xffu);

    return (4);
}

int xsens_imu_sample_time_unpack(
    struct xsens_imu_sample_time_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->timestamp = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    dst_p->timestamp |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    dst_p->timestamp |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    dst_p->timestamp |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);

    return (0);
}

uint32_t xsens_imu_sample_time_timestamp_encode(double value)
{
    return (uint32_t)(value);
}

double xsens_imu_sample_time_timestamp_decode(uint32_t value)
{
    return ((double)value);
}

bool xsens_imu_sample_time_timestamp_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int xsens_imu_group_counter_pack(
    uint8_t *dst_p,
    const struct xsens_imu_group_counter_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_right_shift_u16(src_p->counter, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->counter, 0u, 0xffu);

    return (2);
}

int xsens_imu_group_counter_unpack(
    struct xsens_imu_group_counter_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    dst_p->counter = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->counter |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);

    return (0);
}

uint16_t xsens_imu_group_counter_counter_encode(double value)
{
    return (uint16_t)(value);
}

double xsens_imu_group_counter_counter_decode(uint16_t value)
{
    return ((double)value);
}

bool xsens_imu_group_counter_counter_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int xsens_imu_rate_of_turn_pack(
    uint8_t *dst_p,
    const struct xsens_imu_rate_of_turn_t *src_p,
    size_t size)
{
    uint16_t gyr_x;
    uint16_t gyr_y;
    uint16_t gyr_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    gyr_x = (uint16_t)src_p->gyr_x;
    dst_p[0] |= pack_right_shift_u16(gyr_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(gyr_x, 0u, 0xffu);
    gyr_y = (uint16_t)src_p->gyr_y;
    dst_p[2] |= pack_right_shift_u16(gyr_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(gyr_y, 0u, 0xffu);
    gyr_z = (uint16_t)src_p->gyr_z;
    dst_p[4] |= pack_right_shift_u16(gyr_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(gyr_z, 0u, 0xffu);

    return (6);
}

int xsens_imu_rate_of_turn_unpack(
    struct xsens_imu_rate_of_turn_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t gyr_x;
    uint16_t gyr_y;
    uint16_t gyr_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    gyr_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    gyr_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->gyr_x = (int16_t)gyr_x;
    gyr_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    gyr_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->gyr_y = (int16_t)gyr_y;
    gyr_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    gyr_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->gyr_z = (int16_t)gyr_z;

    return (0);
}

int16_t xsens_imu_rate_of_turn_gyr_x_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_imu_rate_of_turn_gyr_x_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_imu_rate_of_turn_gyr_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_imu_rate_of_turn_gyr_y_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_imu_rate_of_turn_gyr_y_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_imu_rate_of_turn_gyr_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_imu_rate_of_turn_gyr_z_encode(double value)
{
    return (int16_t)(value / 0.001953125);
}

double xsens_imu_rate_of_turn_gyr_z_decode(int16_t value)
{
    return ((double)value * 0.001953125);
}

bool xsens_imu_rate_of_turn_gyr_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int xsens_imu_quaternion_pack(
    uint8_t *dst_p,
    const struct xsens_imu_quaternion_t *src_p,
    size_t size)
{
    uint16_t q1;
    uint16_t q2;
    uint16_t q3;
    uint16_t q4;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    q1 = (uint16_t)src_p->q1;
    dst_p[0] |= pack_right_shift_u16(q1, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(q1, 0u, 0xffu);
    q2 = (uint16_t)src_p->q2;
    dst_p[2] |= pack_right_shift_u16(q2, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(q2, 0u, 0xffu);
    q3 = (uint16_t)src_p->q3;
    dst_p[4] |= pack_right_shift_u16(q3, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(q3, 0u, 0xffu);
    q4 = (uint16_t)src_p->q4;
    dst_p[6] |= pack_right_shift_u16(q4, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(q4, 0u, 0xffu);

    return (8);
}

int xsens_imu_quaternion_unpack(
    struct xsens_imu_quaternion_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t q1;
    uint16_t q2;
    uint16_t q3;
    uint16_t q4;

    if (size < 8u) {
        return (-EINVAL);
    }

    q1 = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    q1 |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->q1 = (int16_t)q1;
    q2 = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    q2 |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->q2 = (int16_t)q2;
    q3 = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    q3 |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->q3 = (int16_t)q3;
    q4 = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    q4 |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);
    dst_p->q4 = (int16_t)q4;

    return (0);
}

int16_t xsens_imu_quaternion_q1_encode(double value)
{
    return (int16_t)(value / 0.000030517578125);
}

double xsens_imu_quaternion_q1_decode(int16_t value)
{
    return ((double)value * 0.000030517578125);
}

bool xsens_imu_quaternion_q1_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_imu_quaternion_q2_encode(double value)
{
    return (int16_t)(value / 0.000030517578125);
}

double xsens_imu_quaternion_q2_decode(int16_t value)
{
    return ((double)value * 0.000030517578125);
}

bool xsens_imu_quaternion_q2_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_imu_quaternion_q3_encode(double value)
{
    return (int16_t)(value / 0.000030517578125);
}

double xsens_imu_quaternion_q3_decode(int16_t value)
{
    return ((double)value * 0.000030517578125);
}

bool xsens_imu_quaternion_q3_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t xsens_imu_quaternion_q4_encode(double value)
{
    return (int16_t)(value / 0.000030517578125);
}

double xsens_imu_quaternion_q4_decode(int16_t value)
{
    return ((double)value * 0.000030517578125);
}

bool xsens_imu_quaternion_q4_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int xsens_imu_free_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_imu_free_acceleration_t *src_p,
    size_t size)
{
    uint16_t free_acc_x;
    uint16_t free_acc_y;
    uint16_t free_acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    free_acc_x = (uint16_t)src_p->free_acc_x;
    dst_p[0] |= pack_right_shift_u16(free_acc_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(free_acc_x, 0u, 0xffu);
    free_acc_y = (uint16_t)src_p->free_acc_y;
    dst_p[2] |= pack_right_shift_u16(free_acc_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(free_acc_y, 0u, 0xffu);
    free_acc_z = (uint16_t)src_p->free_acc_z;
    dst_p[4] |= pack_right_shift_u16(free_acc_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(free_acc_z, 0u, 0xffu);

    return (6);
}

int xsens_imu_free_acceleration_unpack(
    struct xsens_imu_free_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t free_acc_x;
    uint16_t free_acc_y;
    uint16_t free_acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    free_acc_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    free_acc_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->free_acc_x = (int16_t)free_acc_x;
    free_acc_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    free_acc_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->free_acc_y = (int16_t)free_acc_y;
    free_acc_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    free_acc_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->free_acc_z = (int16_t)free_acc_z;

    return (0);
}

int16_t xsens_imu_free_acceleration_free_acc_x_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_imu_free_acceleration_free_acc_x_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_imu_free_acceleration_free_acc_x_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_imu_free_acceleration_free_acc_y_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_imu_free_acceleration_free_acc_y_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_imu_free_acceleration_free_acc_y_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_imu_free_acceleration_free_acc_z_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_imu_free_acceleration_free_acc_z_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_imu_free_acceleration_free_acc_z_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int xsens_imu_euler_angles_pack(
    uint8_t *dst_p,
    const struct xsens_imu_euler_angles_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    roll = (uint16_t)src_p->roll;
    dst_p[0] |= pack_right_shift_u16(roll, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(roll, 0u, 0xffu);
    pitch = (uint16_t)src_p->pitch;
    dst_p[2] |= pack_right_shift_u16(pitch, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(pitch, 0u, 0xffu);
    yaw = (uint16_t)src_p->yaw;
    dst_p[4] |= pack_right_shift_u16(yaw, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(yaw, 0u, 0xffu);

    return (6);
}

int xsens_imu_euler_angles_unpack(
    struct xsens_imu_euler_angles_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t pitch;
    uint16_t roll;
    uint16_t yaw;

    if (size < 6u) {
        return (-EINVAL);
    }

    roll = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    roll |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->roll = (int16_t)roll;
    pitch = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    pitch |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->pitch = (int16_t)pitch;
    yaw = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    yaw |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->yaw = (int16_t)yaw;

    return (0);
}

int16_t xsens_imu_euler_angles_roll_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double xsens_imu_euler_angles_roll_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool xsens_imu_euler_angles_roll_is_in_range(int16_t value)
{
    return ((value >= -23040) && (value <= 23040));
}

int16_t xsens_imu_euler_angles_pitch_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double xsens_imu_euler_angles_pitch_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool xsens_imu_euler_angles_pitch_is_in_range(int16_t value)
{
    return ((value >= -23040) && (value <= 23040));
}

int16_t xsens_imu_euler_angles_yaw_encode(double value)
{
    return (int16_t)(value / 0.0078125);
}

double xsens_imu_euler_angles_yaw_decode(int16_t value)
{
    return ((double)value * 0.0078125);
}

bool xsens_imu_euler_angles_yaw_is_in_range(int16_t value)
{
    return ((value >= -23040) && (value <= 23040));
}

int xsens_imu_delta_v_pack(
    uint8_t *dst_p,
    const struct xsens_imu_delta_v_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    x = (uint16_t)src_p->x;
    dst_p[0] |= pack_right_shift_u16(x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(x, 0u, 0xffu);
    y = (uint16_t)src_p->y;
    dst_p[2] |= pack_right_shift_u16(y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(y, 0u, 0xffu);
    z = (uint16_t)src_p->z;
    dst_p[4] |= pack_right_shift_u16(z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(z, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->exponent, 0u, 0xffu);

    return (7);
}

int xsens_imu_delta_v_unpack(
    struct xsens_imu_delta_v_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t x;
    uint16_t y;
    uint16_t z;

    if (size < 7u) {
        return (-EINVAL);
    }

    x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->x = (int16_t)x;
    y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->y = (int16_t)y;
    z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->z = (int16_t)z;
    dst_p->exponent = unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

int16_t xsens_imu_delta_v_x_encode(double value)
{
    return (int16_t)(value / 0.0000076293945313);
}

double xsens_imu_delta_v_x_decode(int16_t value)
{
    return ((double)value * 0.0000076293945313);
}

bool xsens_imu_delta_v_x_is_in_range(int16_t value)
{
    return (value >= -32767);
}

int16_t xsens_imu_delta_v_y_encode(double value)
{
    return (int16_t)(value / 0.0000076293945313);
}

double xsens_imu_delta_v_y_decode(int16_t value)
{
    return ((double)value * 0.0000076293945313);
}

bool xsens_imu_delta_v_y_is_in_range(int16_t value)
{
    return (value >= -32767);
}

int16_t xsens_imu_delta_v_z_encode(double value)
{
    return (int16_t)(value / 0.0000076293945313);
}

double xsens_imu_delta_v_z_decode(int16_t value)
{
    return ((double)value * 0.0000076293945313);
}

bool xsens_imu_delta_v_z_is_in_range(int16_t value)
{
    return (value >= -32767);
}

uint8_t xsens_imu_delta_v_exponent_encode(double value)
{
    return (uint8_t)(value);
}

double xsens_imu_delta_v_exponent_decode(uint8_t value)
{
    return ((double)value);
}

bool xsens_imu_delta_v_exponent_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int xsens_imu_delta_q_pack(
    uint8_t *dst_p,
    const struct xsens_imu_delta_q_t *src_p,
    size_t size)
{
    uint16_t delta_q1;
    uint16_t delta_q2;
    uint16_t delta_q3;
    uint16_t delta_q4;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    delta_q1 = (uint16_t)src_p->delta_q1;
    dst_p[0] |= pack_right_shift_u16(delta_q1, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(delta_q1, 0u, 0xffu);
    delta_q2 = (uint16_t)src_p->delta_q2;
    dst_p[2] |= pack_right_shift_u16(delta_q2, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(delta_q2, 0u, 0xffu);
    delta_q3 = (uint16_t)src_p->delta_q3;
    dst_p[4] |= pack_right_shift_u16(delta_q3, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(delta_q3, 0u, 0xffu);
    delta_q4 = (uint16_t)src_p->delta_q4;
    dst_p[6] |= pack_right_shift_u16(delta_q4, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(delta_q4, 0u, 0xffu);

    return (8);
}

int xsens_imu_delta_q_unpack(
    struct xsens_imu_delta_q_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t delta_q1;
    uint16_t delta_q2;
    uint16_t delta_q3;
    uint16_t delta_q4;

    if (size < 8u) {
        return (-EINVAL);
    }

    delta_q1 = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    delta_q1 |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->delta_q1 = (int16_t)delta_q1;
    delta_q2 = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    delta_q2 |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->delta_q2 = (int16_t)delta_q2;
    delta_q3 = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    delta_q3 |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->delta_q3 = (int16_t)delta_q3;
    delta_q4 = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    delta_q4 |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);
    dst_p->delta_q4 = (int16_t)delta_q4;

    return (0);
}

int16_t xsens_imu_delta_q_delta_q1_encode(double value)
{
    return (int16_t)(value / 0.000030518509476);
}

double xsens_imu_delta_q_delta_q1_decode(int16_t value)
{
    return ((double)value * 0.000030518509476);
}

bool xsens_imu_delta_q_delta_q1_is_in_range(int16_t value)
{
    return ((value >= -32766) && (value <= 32766));
}

int16_t xsens_imu_delta_q_delta_q2_encode(double value)
{
    return (int16_t)(value / 0.000030518509476);
}

double xsens_imu_delta_q_delta_q2_decode(int16_t value)
{
    return ((double)value * 0.000030518509476);
}

bool xsens_imu_delta_q_delta_q2_is_in_range(int16_t value)
{
    return ((value >= -32766) && (value <= 32766));
}

int16_t xsens_imu_delta_q_delta_q3_encode(double value)
{
    return (int16_t)(value / 0.000030518509476);
}

double xsens_imu_delta_q_delta_q3_decode(int16_t value)
{
    return ((double)value * 0.000030518509476);
}

bool xsens_imu_delta_q_delta_q3_is_in_range(int16_t value)
{
    return ((value >= -32766) && (value <= 32766));
}

int16_t xsens_imu_delta_q_delta_q4_encode(double value)
{
    return (int16_t)(value / 0.000030518509476);
}

double xsens_imu_delta_q_delta_q4_decode(int16_t value)
{
    return ((double)value * 0.000030518509476);
}

bool xsens_imu_delta_q_delta_q4_is_in_range(int16_t value)
{
    return ((value >= -32766) && (value <= 32766));
}

int xsens_imu_acceleration_pack(
    uint8_t *dst_p,
    const struct xsens_imu_acceleration_t *src_p,
    size_t size)
{
    uint16_t acc_x;
    uint16_t acc_y;
    uint16_t acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    acc_x = (uint16_t)src_p->acc_x;
    dst_p[0] |= pack_right_shift_u16(acc_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(acc_x, 0u, 0xffu);
    acc_y = (uint16_t)src_p->acc_y;
    dst_p[2] |= pack_right_shift_u16(acc_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(acc_y, 0u, 0xffu);
    acc_z = (uint16_t)src_p->acc_z;
    dst_p[4] |= pack_right_shift_u16(acc_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(acc_z, 0u, 0xffu);

    return (6);
}

int xsens_imu_acceleration_unpack(
    struct xsens_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t acc_x;
    uint16_t acc_y;
    uint16_t acc_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    acc_x = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    acc_x |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->acc_x = (int16_t)acc_x;
    acc_y = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    acc_y |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->acc_y = (int16_t)acc_y;
    acc_z = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    acc_z |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->acc_z = (int16_t)acc_z;

    return (0);
}

int16_t xsens_imu_acceleration_acc_x_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_imu_acceleration_acc_x_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_imu_acceleration_acc_x_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_imu_acceleration_acc_y_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_imu_acceleration_acc_y_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_imu_acceleration_acc_y_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int16_t xsens_imu_acceleration_acc_z_encode(double value)
{
    return (int16_t)(value / 0.00390625);
}

double xsens_imu_acceleration_acc_z_decode(int16_t value)
{
    return ((double)value * 0.00390625);
}

bool xsens_imu_acceleration_acc_z_is_in_range(int16_t value)
{
    return ((value >= -25600) && (value <= 25600));
}

int xsens_imu_error_pack(
    uint8_t *dst_p,
    const struct xsens_imu_error_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    return (1);
}

int xsens_imu_error_unpack(
    struct xsens_imu_error_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 1u) {
        return (-EINVAL);
    }

    return (0);
}
